'use strict';

var coc_nvim = require('coc.nvim');
var node_child_process = require('node:child_process');
var node_path = require('node:path');
var debounce = require('lodash.debounce');
var portfinder = require('portfinder');

const disposables = [];
async function getFullText() {
  const doc = await coc_nvim.workspace.document;
  return doc.textDocument.getText();
}
async function getSelectedText() {
  const doc = await coc_nvim.workspace.document;
  const range = await coc_nvim.window.getSelectedRange('v');
  return range ? doc.textDocument.getText(range) : '';
}
async function markmapDevelop(cliPromise, assetsDir, opts) {
  const {
    config,
    develop,
    fetchAssets
  } = await cliPromise;
  config.assetsDir = assetsDir;
  await fetchAssets();
  return develop(undefined, {
    open: true,
    toolbar: true,
    offline: true,
    ...opts
  });
}
async function markmapCreate(cliPromise, assetsDir, args) {
  const {
    config,
    createMarkmap,
    fetchAssets
  } = await cliPromise;
  config.assetsDir = assetsDir;
  await fetchAssets();
  return createMarkmap({
    open: true,
    toolbar: true,
    offline: false,
    ...args
  });
}
async function startDevelop(assetsDir) {
  if (disposables.length > 0) {
    for (const disposable of disposables) {
      disposable.dispose();
    }
    disposables.length = 0;
  }
  const port = await portfinder.getPortPromise();
  const p = runJS(`(${markmapDevelop})(import('markmap-cli'), ${JSON.stringify(assetsDir)}, ${JSON.stringify({
    port
  })})`);
  const rpc = async (cmd, args) => {
    // console.log('RPC:', cmd, args);
    try {
      const res = await fetch(`http://localhost:${port}/~api`, {
        method: 'POST',
        headers: {
          'content-type': 'application/json'
        },
        body: JSON.stringify({
          cmd,
          args
        })
      });
      if (!res.ok) {
        throw new Error(`Request error: ${res.status}`);
      }
      return true;
    } catch (err) {
      console.error(err);
      return false;
    }
  };
  const {
    nvim
  } = coc_nvim.workspace;
  const buffer = await nvim.buffer;
  const updateContent = async () => {
    const lines = await buffer.getLines();
    return await rpc('setContent', [lines.join('\n')]);
  };
  const handleTextChange = debounce(bufnr => {
    if (buffer.id !== bufnr) {
      return;
    }
    updateContent();
  }, 500);
  const handleCursor = debounce(bufnr => {
    if (buffer.id !== bufnr) {
      return;
    }
    rpc('setCursor', [coc_nvim.events.cursor.lnum - 1]);
  }, 300);
  disposables.push(coc_nvim.Disposable.create(() => p.kill()));
  disposables.push(coc_nvim.events.on('TextChanged', handleTextChange));
  disposables.push(coc_nvim.events.on('TextChangedI', handleTextChange));
  disposables.push(coc_nvim.events.on('CursorMoved', handleCursor));
  disposables.push(coc_nvim.events.on('CursorMovedI', handleCursor));
  let time = 1000;
  for (let i = 0; i < 3; i += 1) {
    await delay(time);
    if (await updateContent()) {
      time = 0;
      break;
    }
    time *= 2;
  }
  if (time) {
    coc_nvim.window.showErrorMessage('Error starting server');
    p.kill();
  } else {
    coc_nvim.window.showInformationMessage(`Markmap served at http://localhost:${port}`);
  }
}
function delay(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
async function createMarkmapFromVim(assetsDir, content, options) {
  const mergedOptions = {
    watch: false,
    offline: false,
    ...options
  };
  if (mergedOptions.watch) {
    return startDevelop(assetsDir);
  }
  const {
    nvim
  } = coc_nvim.workspace;
  const input = await nvim.eval('expand("%:p")');
  const name = node_path.basename(input, node_path.extname(input));
  const output = node_path.resolve(`${name}.html`);
  const createOptions = {
    content,
    output,
    ...mergedOptions
  };
  runJS(`(${markmapCreate})(import('markmap-cli'), ${JSON.stringify(assetsDir)}, ${JSON.stringify(createOptions)})`);
}
function runJS(code) {
  // console.log('runJS', code);
  return node_child_process.spawn(process.execPath, ['-e', code], {
    cwd: __dirname
  });
}
function activate(context) {
  // const config = workspace.getConfiguration('markmap');
  const assetsDir = context.storagePath;
  context.subscriptions.push(coc_nvim.workspace.registerKeymap(['n'], 'markmap-create', async () => {
    const content = await getFullText();
    await createMarkmapFromVim(assetsDir, content);
  }, {
    sync: false
  }));
  context.subscriptions.push(coc_nvim.workspace.registerKeymap(['v'], 'markmap-create-v', async () => {
    const content = await getSelectedText();
    await createMarkmapFromVim(assetsDir, content);
  }, {
    sync: false
  }));
  context.subscriptions.push(coc_nvim.commands.registerCommand('markmap.create', async (...args) => {
    const content = await getFullText();
    const options = {
      offline: args.includes('--offline')
    };
    await createMarkmapFromVim(assetsDir, content, options);
  }));
  context.subscriptions.push(coc_nvim.commands.registerCommand('markmap.watch', async () => {
    const content = await getFullText();
    await createMarkmapFromVim(assetsDir, content, {
      watch: true
    });
  }));
}

exports.activate = activate;
